### 算法思想

基础思路： 枚举、递推、递归、

| 算法 | 思想 | 应用 |
| ---- | ---- | ---- |
| [分治法](https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95) | 把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并 | [循环赛日程安排问题](https://github.com/huihut/interview/tree/master/Problems/RoundRobinProblem)、排序算法（快速排序、归并排序） |
| [动态规划](https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92) | 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，适用于有重叠子问题和最优子结构性质的问题 | [背包问题](https://github.com/huihut/interview/tree/master/Problems/KnapsackProblem)、斐波那契数列 |
| [贪心法](https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E6%B3%95) | 一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法 | 旅行推销员问题（最短路径问题）、最小生成树、哈夫曼编码 |
| [回溯法](https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BA%AF%E6%B3%95) | 一种可以找出所有（或一部分）解的一般性算法，尤其适用于[约束满足问题](https://zh.wikipedia.org/wiki/%E7%B4%84%E6%9D%9F%E6%BB%BF%E8%B6%B3%E5%95%8F%E9%A1%8C "约束满足问题")（在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解） | [八皇后问题](https://zh.wikipedia.org/wiki/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98)、深度优先搜索、0-1背包问题、正则表达式匹配 |

[95% 的算法都是基于这 6 种算法思想 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/428479862)

## 排序


| 排序算法 | 平均时间复杂度 | 最差时间复杂度 | 空间复杂度 | 数据对象稳定性 | 思路 |
| ---- | ---- | ---- | ---- | ---- | ---- |
| [冒泡排序](https://github.com/su-dd/learning/blob/main/src/algorithm/sort/Sort_Bubble.h)| O(n2) | O(n2) | O(1) | 稳定 | （无序区，有序区）  <br>从无序区透过交换找出最大元素放到有序区前端 |
| [选择排序](https://github.com/su-dd/learning/blob/main/src/algorithm/sort/Sort_Selection.h) | O(n2) | O(n2) | O(1) | 数组不稳定、链表稳定 | （有序区，无序区）<br>在无序区里找一个最小的元素跟在有序区的后面。对数组：比较得多，换得少 |
| [插入排序](https://github.com/su-dd/learning/blob/main/src/algorithm/sort/Sort_Insert.h) | O(n2) | O(n2) | O(1) | 稳定 | （有序区，无序区）<br>把无序区的第一个元素插入到有序区的合适的位置。对数组：比较得少，换得多 |
| [快速排序](https://github.com/su-dd/learning/blob/main/src/algorithm/sort/Sort_Quick.h) | O(n*log2n) | O(n2) | O(log2n) | 不稳定 | （小数，基准元素，大数）  <br>在区间中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序 |
| [堆排序](https://github.com/su-dd/learning/blob/main/src/algorithm/sort/Sort_Heap.h) | O(n*log2n) | O(n*log2n) | O(1) | 不稳定 | （最大堆，有序区）  <br>从堆顶把根卸出来放在有序区之前，再恢复堆 |
| [归并排序](https://github.com/su-dd/learning/blob/main/src/algorithm/sort/Sort_Merge.h) | O(n*log2n) | O(n*log2n) | O(n) | 稳定 | 把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。 <br>可从上到下或从下到上进行 |
| [希尔排序](https://github.com/su-dd/learning/blob/main/src/algorithm/sort/Sort_Shell.h) | O(n*log2n) | O(n2) | O(1) | 不稳定 | 每一轮按照事先决定的间隔进行插入排序，间隔会依次缩小，最后一次一定要是1 |
| [计数排序](https://github.com/su-dd/learning/blob/main/src/algorithm/sort/Sort_Count.h) | O(n+m) | O(n+m) | O(n+m) | 稳定 | 统计小于等于该元素值的元素的个数i，于是该元素就放在目标数组的索引i位（i≥0） |
| [桶排序](https://github.com/su-dd/learning/blob/main/src/algorithm/sort/Sort_Bucket.h) | O(n) | O(n) | O(m) | 稳定 | 将值为i的元素放入i号桶，最后依次把桶里的元素倒出来 |
| [基数排序](https://github.com/su-dd/learning/blob/main/src/algorithm/sort/Sort_Radix.h) | O(k*n) | O(n2) |  | 稳定 | 一种多关键字的排序算法，可用桶排序实现 |

> 1. 均按从小到大排列 
> 2. k代表数值中的"数位"个数
> 3. n代表数据规模 
> 4. m代表数据的最大值减最小值

[排序算法 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)


### 冒泡排序

**算法：**
		数据：（无序区，有序区）。
		从无序区通过交换找出最大元素放到有序区前端。

**步骤：**
		1. 比较相邻的元素。如果第一个比第二个大，就交换它们两个。
		2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
		3. 针对所有的元素重复以上的步骤，除了最后一个。
		4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。


```cpp
// 模板方法实现冒泡
template<typename T>
void sort_bubble(std::vector<T> &array)
{
	int len = array.size();
	for (int i = 0; i < len - 1; i ++)
	{
		for (int j = 0; j < len - 1 - i; j++)
		{
			if (array[j] > array[j + 1])
			{
				std::swap(array[j], array[j + 1]);
			}
		}
	}
}
```

### 选择排序

**算法：**
		数据：（有序区，无序区）
		在无序区里找一个最小的元素跟在有序区的后面。对数组：比较得多，换得少

**步骤：**
		1. 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
		2. 从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾
		3. 以此类推，直到所有元素均排序完毕

```cpp
// 升序的选择排序
template<typename T>
void sort_select(std::vector<T>& array)
{
	int len = array.size();
	for (int i = 0; i < len - 1; i++) {
		int min = i;
		for (int j = i + 1; j < len; j++)
		{
			if (array[j] < array[min])
				min = j;
		}
		if (i != min)
			std::swap(array[i], array[min]);
	}
}
```

### 插入排序

**算法：**
		数据：（有序区，无序区）。
		把无序区的第一个元素插入到有序区的合适的位置。对数组：比较得少，换得多。

**步骤：**
		1. 从第一个元素开始，该元素可以认为已经被排序
		2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
		3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
		4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
		5. 将新元素插入到该位置后
		6. 重复步骤2~5

```cpp
template<typename T>
void sort_insert(std::vector<T>& array)
{
	for (int i = 1; i < array.size(); i++)
	{
		T temp = array[i];
		for (int k = i - 1; k >= 0; k--)
		{
			if (temp < array[k])
			{
				array[k + 1] = array[k];
				array[k] = temp;
			}
			else
				break;
		}
	}
}
```


### 快速排序

**算法：**
		数据：（小数，基准元素，大数）。
		在区间中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序。

**步骤：**
		1. 选取第一个数为基准
		2. 将比基准小的数交换到前面，比基准大的数交换到后面
		3. 对左右区间重复第二步，直到各区间只有一个数

```cpp
// 快速排序（递归）
template<typename T>
void sort_quick_recursive(std::vector<T>& array, int start, int end)
{
    if (start >= end) return;
    T mid = array[end]; // 标志数据
    int left = start, right = end - 1;
    while (left < right)
    {
        while (array[left] < mid && left < right)
            left++;
        while (array[right] >= mid && left < right)
            right--;
        std::swap(array[left], array[right]);
    }

    // 这时 left和right的值相同，判断当前值和mid（标志数据）的大小；做交换，保障顺序
    if (array[left] > mid)       
        std::swap(array[left], array[end]);

    sort_quick_recursive(array, start, left - 1);
    sort_quick_recursive(array, left + 1, end);
}

template<typename T>
void sort_quick_recursion(std::vector<T>& array)
{
    sort_quick_recursive<int>(array, 0, array.size() - 1);
}

// 快速排序（迭代）
struct Range {
    int start, end;
    Range(int s = 0, int e = 0) {
        start = s, end = e;
    }
};

// 整数或浮点数皆可使用,若要使用物件(class)时必须设定"小于"(<)、"大于"(>)、"不小于"(>=)的运算子功能
template <typename T> 
void sort_quick_iterate(std::vector<T> &array) {
    int len = array.size();
    std::stack<Range> rangeStack;
    rangeStack.emplace(0, len - 1);

    while (!rangeStack.empty()) {
        Range curRange = rangeStack.top();
        rangeStack.pop();

        if (curRange.start >= curRange.end)
            continue;

        T mid = array[curRange.end];   // 标志数据

        int left = curRange.start, right = curRange.end - 1;

        while (left < right) 
        {
            while (array[left] < mid && left < right) 
                left++;
            while (array[right] >= mid && left < right)
                right--;

            if (left < right)
                std::swap(array[left], array[right]);
        }

        // 这时 left和right的值相同，判断当前值和mid（标志数据）的大小；做交换，保障顺序
        if (array[left] > mid)
            std::swap(array[left], array[curRange.end]);

        // 模拟递归
        rangeStack.emplace(curRange.start, left - 1);
        rangeStack.emplace(left + 1, curRange.end);
    }
}
```

### 堆排序

**算法：**
		数据：（最大堆，有序区）  
		从堆顶把根卸出来放在有序区之前，再恢复堆

 通堆是通过一维数组来实现的，在数组起始位置为0的情形中：
        1. 父节点i的左子节点在位置(2i+1)
        2. 父节点i的右子节点在位置(2i+2)
        3. 子节点i的父节点在位置 (i-1)/2

**步骤：**
		1. 将当前排序调整为堆的结构
        2. 将堆定数据取出，交换到有序取的最前面
        3. 将剩下的堆回复到堆的结构
        4. 重复2~3步骤

```cpp

template<typename T>
void max_heapify(std::vector<T> &array, int parentIndex)    // 大顶堆调整
{
    // 建立 父节点指针位置 和 子节点指针位置
    int dadIndex = parentIndex;
    int sonIndex = dadIndex * 2 + 1;
    int maxIndex = array.size() - 1;
    while (sonIndex <= maxIndex)
    { // 若 子节点指针位置 在范围內才做比较
        if (sonIndex + 1 <= maxIndex && array[sonIndex] > array[sonIndex + 1]) // 先比较两个子节点大小，选择小的
            sonIndex++;
        if (array[dadIndex] < array[sonIndex]) // 如果 父节点 < 子节点 代表调整完成，直接跳出函数
            return;
        else 
        {   // 否则较换父子內容再继续子节点和孙节点比较
            std::swap(array[dadIndex], array[sonIndex]);
            // 因为这里的循环是从树的叶子节点开始的，但当处理dadIndex时，他下面已经是堆了，所以只需要对dadIndex的值进行处理
            dadIndex = sonIndex;                
            sonIndex = dadIndex * 2 + 1;
        }
    }
}

template<typename T>
void sort_heap(std::vector<T>& array)
{   
    // 建立堆结构
    // 初始化，i从最后一个父节点开始调整
    int maxIndex = array.size() - 1;
    for (int i = (maxIndex - 1) / 2; i >= 0; i--)
        max_heapify(array, i);

    // 先将第一个元素和已经排好的元素前一位做较换，再从新调整(刚调整的元素之前的元素)，直到排序完成
    for (int i = maxIndex; i > 0; i--)
    {
        std::swap(array[0], array[i]);  // 取堆定数据交换到有序区
        max_heapify(array, 0);
    }
}
```


### 归并排序

**算法：**
		把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。 
		可从上到下或从下到上进行
		
**递归法（Top-down）**
		1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
		2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
		3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
		4. 重复步骤3直到某一指针到达序列尾
		5. 将另一序列剩下的所有元素直接复制到合并序列尾
```cpp
template<typename T>
void sort_merge_recursive(std::vector<T>& array, std::vector<T>& temp, int start, int end)
{
	if (start >= end)
		return;

	int len = end - start;
	int mid = len / 2 + start;
	int start1 = start, end1 = mid;
	int start2 = mid + 1, end2 = end;
	sort_merge_recursive(array, temp, start1, end1);
	sort_merge_recursive(array, temp, start2, end2);
	
	int k = start;
	while (start1 <= end1 && start2 <= end2)
		temp[k++] = (array[start1] <= array[start2] ? array[start1++] : array[start2++]);

	while (start1 <= end1)
		temp[k++] = array[start1++];
		
	while (start2 <= end2)
		temp[k++] = array[start2++];

	for (int k = start; k <= end; k++)	// 将排序好的数据，回到array中，以便后续使用
		array[k] = temp[k];
}

//整数或浮点数皆可使用,若要使用物件(class)时必须设定"小于"(<)的运算子功能
template<typename T>
void sort_merge_recursion(std::vector<T> &array)
{
	std::vector<T> temp(array);
	sort_merge_recursive(array, temp, 0, array.size() - 1);
}
```


**迭代法（Bottom-up）**
	原理如下（假设序列共有n个元素）：
		1. 将序列每相邻两个数字进行归并操作，形成ceil(n/2)个序列，排序后每个序列包含两/一个元素
		2. 若此时序列数不是1个则将上述序列再次归并，形成ceil(n/4)个序列，每个序列包含四/三个元素
		3. 重复步骤2，直到所有元素排序完毕，即序列数为1

```cpp
//整数或浮点数皆可使用,若要使用物件(class)时必须设定"小于"(<)的运算子功能
template<typename T>
void sort_merge_iterate(std::vector<T> &array) {
	std::vector<T> temp(array);
	int len = array.size();
	// seg 为合并的区间大小，从1开始，后面每次乘2
	for (int seg = 1; seg < len; seg += seg)
	{
		for (int start = 0; start < len; start += seg + seg) 
		{
			int low = start;
			int mid = std::min(start + seg, len);
			int high = std::min(start + seg + seg, len);

			int start1 = low, end1 = mid;
			int start2 = mid, end2 = high;

			int k = low;
			while (start1 < end1 && start2 < end2)
				temp[k++] = array[start1] <= array[start2] ? array[start1++] : array[start2++];
			while (start1 < end1)
				temp[k++] = array[start1++];
			while (start2 < end2)
				temp[k++] = array[start2++];

			// 将排序好的数据，回到array中，以便后续使用
			for (int k = low; k < high; k++)
				array[k] = temp[k];
		}
	}
}
```


### 希尔排序

**算法：**
	先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序

![](img/design_pattern/20240117233759.png)

**步骤：**
	1. 先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。  
	2.  所有距离为d1的倍数的记录放在同一个组中，在各组内进行直接插入排序。  
	3.  取第二个增量d2小于d1重复上述的分组和排序，直至所取的增量dt=1(dt小于dt-l小于…小于d2小于d1)，即所有记录放在同一组中进行直接插入排序为止。

```cpp
template<typename T>
void shell_sort(std::vector<T> array) {
    int len = array.size();

    int h = 1;
    while (h < len / 3) // 寻找一个合适的增量
    {
        h = 3 * h + 1;
    }

    while (h >= 1) 
    {
        for (int i = h; i < len; i++) // 共划分出 （len - 1 - h）个数组
        {
            // 按h作为增量，划分的子序列中做插入排序;
            // 这里的插入排序，是最开始只取两个保证有序，再慢慢添加
            for (int j = i; j >= h && temp < array[j - h]; j -= h)  
            {
                std::swap(array[j], array[j - h]);
            }
        }
        h = h / 3;
    }
}
```

### 计数排序

**算法：** 统计小于等于该元素值的元素的个数i，于是该元素就放在目标数组的索引i位（i≥0）。
	计数排序基于一个假设，待排序数列的所有数均为整数，且出现在（0，k）的区间之内。
	如果 k（待排数组的最大值） 过大则会引起较大的空间复杂度，一般是用来排序 0 到 100 之间的数字的最好的算法，但是它不适合按字母顺序排序人名。
	计数排序不是比较排序，排序的速度快于任何比较排序算法。
	时间复杂度为 O（n+k），空间复杂度为 O（n+k）

**步骤：**
	1. 找出待排序的数组中最大和最小的元素
	2. 统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项
	3. 对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）
	4. 反向填充目标数组：将每个元素 i 放在新数组的第 C[i] 项，每放一个元素就将 C[i] 减去 1

```cpp

```

### 桶排序


### 基数排序



## 查找

| 查找算法 | 平均时间复杂度 | 空间复杂度 | 查找条件 |
| ---- | ---- | ---- | ---- |
| [顺序查找](https://github.com/huihut/interview/blob/master/Algorithm/SequentialSearch.h) | O(n) | O(1) | 无序或有序 |
| [二分查找（折半查找）](https://github.com/huihut/interview/blob/master/Algorithm/BinarySearch.h) | O(log2n) | O(1) | 有序 |
| [插值查找](https://github.com/huihut/interview/blob/master/Algorithm/InsertionSearch.h) | O(log2(log2n)) | O(1) | 有序 |
| [斐波那契查找](https://github.com/huihut/interview/blob/master/Algorithm/FibonacciSearch.cpp) | O(log2n) | O(1) | 有序 |
| [哈希查找](https://github.com/huihut/interview/blob/master/DataStructure/HashTable.cpp) | O(1) | O(n) | 无序或有序 |
| [二叉查找树（二叉搜索树查找）](https://github.com/huihut/interview/blob/master/Algorithm/BSTSearch.h) | O(log2n) |  |  |
| [红黑树](https://github.com/huihut/interview/blob/master/DataStructure/RedBlackTree.cpp) | O(log2n) |  |  |
| 2-3树 | O(log2n - log3n) |  |  |
| B树/B+树 | O(log2n) |  |  |



## 图搜索

|图搜索算法|数据结构|遍历时间复杂度|空间复杂度|
|---|---|---|---|
|[BFS广度优先搜索](https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2)|邻接矩阵  <br>邻接链表|O(\|v\|2)  <br>O(\|v\|+\|E\|)|O(\|v\|2)  <br>O(\|v\|+\|E\|)|
|[DFS深度优先搜索](https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2)|邻接矩阵  <br>邻接链表|O(\|v\|2)  <br>O(\|v\|+\|E\|)|O(\|v\|2)  <br>O(\|v\|+\|E\|)|

## 经典算法题

