### 算法思想

基础思路： 枚举、递推、递归、

| 算法 | 思想 | 应用 |
| ---- | ---- | ---- |
| [分治法](https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95) | 把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并 | [循环赛日程安排问题](https://github.com/huihut/interview/tree/master/Problems/RoundRobinProblem)、排序算法（快速排序、归并排序） |
| [动态规划](https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92) | 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，适用于有重叠子问题和最优子结构性质的问题 | [背包问题](https://github.com/huihut/interview/tree/master/Problems/KnapsackProblem)、斐波那契数列 |
| [贪心法](https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E6%B3%95) | 一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法 | 旅行推销员问题（最短路径问题）、最小生成树、哈夫曼编码 |
| [回溯法](https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BA%AF%E6%B3%95) | 一种可以找出所有（或一部分）解的一般性算法，尤其适用于[约束满足问题](https://zh.wikipedia.org/wiki/%E7%B4%84%E6%9D%9F%E6%BB%BF%E8%B6%B3%E5%95%8F%E9%A1%8C "约束满足问题")（在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解） | [八皇后问题](https://zh.wikipedia.org/wiki/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98)、深度优先搜索、0-1背包问题、正则表达式匹配 |

[95% 的算法都是基于这 6 种算法思想 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/428479862)

## 排序

| 排序算法 | 平均时间复杂度 | 最差时间复杂度 | 空间复杂度 | 数据对象稳定性 | 思路 |
| ---- | ---- | ---- | ---- | ---- | ---- |
| [冒泡排序](https://github.com/su-dd/learning/blob/main/src/algorithm/sort/Sort_Bubble.h)| O(n2) | O(n2) | O(1) | 稳定 | （无序区，有序区）  <br>从无序区透过交换找出最大元素放到有序区前端 |
| [选择排序](https://github.com/su-dd/learning/blob/main/src/algorithm/sort/Sort_Selection.h) | O(n2) | O(n2) | O(1) | 数组不稳定、链表稳定 | （有序区，无序区）<br>在无序区里找一个最小的元素跟在有序区的后面。对数组：比较得多，换得少 |
| [插入排序](https://github.com/su-dd/learning/blob/main/src/algorithm/sort/Sort_Insert.h) | O(n2) | O(n2) | O(1) | 稳定 | （有序区，无序区）<br>把无序区的第一个元素插入到有序区的合适的位置。对数组：比较得少，换得多 |
| [快速排序](https://github.com/su-dd/learning/blob/main/src/algorithm/sort/Sort_Quick.h) | O(n*log2n) | O(n2) | O(log2n) | 不稳定 | （小数，基准元素，大数）  <br>在区间中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序 |
| [堆排序](https://github.com/su-dd/learning/blob/main/src/algorithm/sort/Sort_Heap.h) | O(n*log2n) | O(n*log2n) | O(1) | 不稳定 | （最大堆，有序区）  <br>从堆顶把根卸出来放在有序区之前，再恢复堆 |
| [归并排序](https://github.com/su-dd/learning/blob/main/src/algorithm/sort/Sort_Insert.h) | O(n*log2n) | O(n*log2n) | O(n) | 稳定 | 把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。 <br>可从上到下或从下到上进行 |
| [希尔排序](https://github.com/su-dd/learning/blob/main/src/algorithm/sort/Sort_Insert.h) | O(n*log2n) | O(n2) | O(1) | 不稳定 | 每一轮按照事先决定的间隔进行插入排序，间隔会依次缩小，最后一次一定要是1 |
| [计数排序](https://github.com/su-dd/learning/blob/main/src/algorithm/sort/Sort_Insert.h) | O(n+m) | O(n+m) | O(n+m) | 稳定 | 统计小于等于该元素值的元素的个数i，于是该元素就放在目标数组的索引i位（i≥0） |
| [桶排序](https://github.com/su-dd/learning/blob/main/src/algorithm/sort/Sort_Insert.h) | O(n) | O(n) | O(m) | 稳定 | 将值为i的元素放入i号桶，最后依次把桶里的元素倒出来 |
| [基数排序](https://github.com/su-dd/learning/blob/main/src/algorithm/sort/Sort_Insert.h) | O(k*n) | O(n2) |  | 稳定 | 一种多关键字的排序算法，可用桶排序实现 |

> 1. 均按从小到大排列 
> 2. k代表数值中的"数位"个数
> 3. n代表数据规模 
> 4. m代表数据的最大值减最小值

[排序算法 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)



## 查找

| 查找算法 | 平均时间复杂度 | 空间复杂度 | 查找条件 |
| ---- | ---- | ---- | ---- |
| [顺序查找](https://github.com/huihut/interview/blob/master/Algorithm/SequentialSearch.h) | O(n) | O(1) | 无序或有序 |
| [二分查找（折半查找）](https://github.com/huihut/interview/blob/master/Algorithm/BinarySearch.h) | O(log2n) | O(1) | 有序 |
| [插值查找](https://github.com/huihut/interview/blob/master/Algorithm/InsertionSearch.h) | O(log2(log2n)) | O(1) | 有序 |
| [斐波那契查找](https://github.com/huihut/interview/blob/master/Algorithm/FibonacciSearch.cpp) | O(log2n) | O(1) | 有序 |
| [哈希查找](https://github.com/huihut/interview/blob/master/DataStructure/HashTable.cpp) | O(1) | O(n) | 无序或有序 |
| [二叉查找树（二叉搜索树查找）](https://github.com/huihut/interview/blob/master/Algorithm/BSTSearch.h) | O(log2n) |  |  |
| [红黑树](https://github.com/huihut/interview/blob/master/DataStructure/RedBlackTree.cpp) | O(log2n) |  |  |
| 2-3树 | O(log2n - log3n) |  |  |
| B树/B+树 | O(log2n) |  |  |

## 图搜索

|图搜索算法|数据结构|遍历时间复杂度|空间复杂度|
|---|---|---|---|
|[BFS广度优先搜索](https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2)|邻接矩阵  <br>邻接链表|O(\|v\|2)  <br>O(\|v\|+\|E\|)|O(\|v\|2)  <br>O(\|v\|+\|E\|)|
|[DFS深度优先搜索](https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2)|邻接矩阵  <br>邻接链表|O(\|v\|2)  <br>O(\|v\|+\|E\|)|O(\|v\|2)  <br>O(\|v\|+\|E\|)|

## 经典算法题

